# AST Schema Design

## Overview

This document outlines the design principles and implementation strategy for the TypeScript AST schema and code generation system in Arbores.

## Key Principles

### 1. Data-Driven Code Generation

We adopt a **JSON Schema-based, data-driven approach** for code generation rather than manual type definitions:

- All AST types, converters, and utilities are generated from JSON schemas
- Schemas serve as the single source of truth for AST structure
- Generated code includes clear attribution to the generating script
- No manual modification of generated code

### 2. SyntaxKind Group Analysis

TypeScript's `SyntaxKind` enum is organized into logical groups marked by boundary markers:

- **First/Last Markers**: `FirstXxx` and `LastXxx` mark the start and end of each group
- **Shared Characteristics**: Nodes within each group share common properties and behaviors
- **Schema Organization**: Group analysis informs our AST schema organization

Example groups:
- `FirstToken` (0) to `LastToken` - All token types
- `FirstKeyword` (83) to `LastKeyword` - Language keywords  
- `FirstNode` (166) to end - Actual AST nodes
- `FirstTypeNode` (182) to `LastTypeNode` (205) - Type-related nodes
- `FirstStatement` (243) to `LastStatement` (259) - Statement nodes

### 3. Code Generation Standards

All code generation scripts must follow these standards:

#### Command Line Interface
- Use `commander` library for consistent CLI
- Provide `--dry-run` option for preview mode
- Include helpful descriptions and examples
- Configure in `package.json` scripts section

#### Generated Code Headers
```typescript
// WARNING: This file is AUTO-GENERATED by scripts/[script-name].ts
// DO NOT EDIT MANUALLY - Your changes will be overwritten!
// Generated from [source] 
```

#### Stability Requirements
- No timestamps or unstable information in generated code
- Deterministic output given same inputs
- Version-controlled schemas ensure reproducible builds

### 4. Project Structure

```
scripts/
  â”œâ”€â”€ generate-syntax-kind-names.ts         # Legacy SyntaxKind name mapping
  â”œâ”€â”€ generate-syntax-kind-analysis.ts      # âœ… Enhanced SyntaxKind analyzer
  â”œâ”€â”€ generate-ast-schemas.ts               # JSON schema generation (TODO)
  â”œâ”€â”€ generate-ast-types.ts                 # TypeScript types from schemas (TODO)
  â””â”€â”€ generate-ast-converters.ts            # Conversion functions (TODO)
  
src/core/
  â”œâ”€â”€ syntax-kind-names.ts                  # âœ… Generated: SyntaxKind mappings & groups
  â”œâ”€â”€ syntax-kind-names.json                # âœ… Generated: Simple name mapping
  â”œâ”€â”€ syntax-kind-analysis.json             # âœ… Generated: Complete analysis data
  â”œâ”€â”€ ast-schemas.ts                        # Generated: JSON schemas (TODO)
  â”œâ”€â”€ ast-types.ts                          # Generated: TypeScript types (TODO)
  â””â”€â”€ ast-converters.ts                     # Generated: Conversion functions (TODO)

docs/
  â”œâ”€â”€ ast-schema-design.md                  # This document
  â”œâ”€â”€ syntax-kind-analysis.md               # SyntaxKind group analysis
  â””â”€â”€ syntax-kind-ruler.md                  # âœ… Generated: Group visualization
```

## Implementation Roadmap

### Phase 1: Foundation âœ… COMPLETED
1. **SyntaxKind Analysis Script** âœ…
   - âœ… Parse TypeScript SyntaxKind enum
   - âœ… Identify boundary markers (FirstXxx/LastXxx)
   - âœ… Generate group analysis and ruler visualization
   - âœ… Output clean data structures without processing functions
   - âœ… Enhanced analysis with 13 identified groups
   - âœ… Generated comprehensive documentation and visualizations

2. **Documentation** âœ…
   - âœ… Complete SyntaxKind group analysis
   - âœ… Document shared characteristics of each group
   - âœ… Establish naming conventions
   - âœ… Generated ruler visualization and group details

### Phase 2: Schema Generation ðŸš§ IN PROGRESS
1. **JSON Schema Development**
   - Create base schema for common AST node properties
   - Define group-specific schemas based on SyntaxKind analysis
   - Establish inheritance and composition patterns

2. **Schema Validation**
   - Validate schemas against real TypeScript AST samples
   - Ensure coverage of all supported node types
   - Performance testing for large ASTs

### Phase 3: Code Generation
1. **Type Generation**
   - Generate TypeScript interfaces from JSON schemas
   - Create union types for node categories
   - Generate type guards and utility functions

2. **Converter Generation**
   - Generate TypeScript AST to Schema AST converters
   - Generate Schema AST to TypeScript AST converters
   - Create validation and error handling

### Phase 4: Integration
1. **CLI Integration**
   - Update parser commands to use new schema system
   - Maintain backward compatibility where possible
   - Performance optimization

2. **Testing & Documentation**
   - Comprehensive test coverage
   - Update user documentation
   - Migration guide for existing code

## Technical Decisions

### Schema Format
- Use JSON Schema Draft 7 for maximum tooling compatibility
- Separate schemas for different node categories
- Composition over inheritance for flexibility

### Naming Conventions
- Schema files: `{group}-schema.json`
- Generated types: `{Group}Node`, `{Group}NodeType`
- Converters: `to{Group}Node()`, `from{Group}Node()`

### Performance Considerations
- Lazy loading of schema definitions
- Efficient conversion algorithms
- Memory-conscious AST processing

## Benefits

1. **Maintainability**: Single source of truth reduces inconsistencies
2. **Extensibility**: Adding new node types only requires schema updates
3. **Validation**: JSON Schema provides built-in validation capabilities
4. **Tooling**: Rich ecosystem of JSON Schema tools and generators
5. **Documentation**: Schemas serve as documentation for AST structure

## Next Steps

1. Reset current mixed state and implement SyntaxKind analysis script
2. Complete comprehensive SyntaxKind group analysis documentation
3. Begin JSON schema design based on group characteristics
4. Establish code generation pipeline with proper tooling

---

*This document serves as the master plan for AST schema implementation. All implementation decisions should align with these principles.*
